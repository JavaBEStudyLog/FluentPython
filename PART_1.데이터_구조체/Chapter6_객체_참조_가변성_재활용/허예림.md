## Chapter6. 객체 참조, 가변성, 재활용

### 6.1 변수의 개념

```python
a = [1, 2, 3]
b = a
a.append(4)
print(b) # 1,2,3,4
```

- 위의 코드 실행 결과로 실제 변수 동작 방식을 이해할 수 있다.
- 할당한다
    - 객체는 변수가 할당되기 전에 생성된다.
    - 따라서 객체에 X 명칭을 바인딩 한다 라는 말이 적절하다.

### 6.3 정체성, 동일성, 별칭

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a==b)
print(a is not b)
```

- ==는 값 비교, is not 은 주소 비교
- 즉 값은 동일하지만 정체성은 다르다고 판단

**is 연산자가 == 연산자보다 빠르다**

- is 연산자는 오버로딩 할 수 없다.
- is 연산자는 단순히 객체의 id가 같은지만 확인하면 되므로 빠르다
- == 연산자는  __eq__의 편리 구문이다. 대부분 내장형은 이 메서드를 오버라이드해서 객체의 속성 값을 고려하고 조금 더 의미 있게 비교한다. → 동치 비교 시 상당한 처리가 필요할 수 있다
- == 연산자는 객체의 내용을 확인해야 해서 is보다 상대적으로 느릴 수 있다.

**튜플의 상대적 불변성**

- 튜플 자체는 불변형이지만, 참조된 항목이 가변형이면 참조된 항목은 변할 수 있다.
- 튜플의 불변성은 tuple 데이터 구조체의 물리적인 내용에만 한정되며 참조된 객체까지 불변성을 갖지 않는다.
- 동치성과 정체성 간의 차이는 객체를 복사할 때 더 큰 영향을 미친다. 사본 ID가 다른 동일한 객체이다. 그러나 객체가 다른 객체를 담고 있을 때 복사하면 내부 객체도 복사해야 할까?

### 6.4 기본 복사는 얕은 복사

**shallow copy**

- 주소 값을 복사하는 것
- 슬라이싱을 사용한 복사는 대부분 얕은 복사이다.
- 내부 참조가 그대로 복사된다.
- copy 모듈의 copy()는 얕은 복사이다.
- 객체의 각각 속성을 메모리에 할당하는 데 시간이 소요되므로 얕은 복사도 얕은 복사의 활용도가 있다.

**deep copy**

- 실제 값을 새로운 메모리 공간에 복사하는 것
- 복사를 하는 목적은 기존 객체의 값만 복사본으로 가져와 별도로 활용하기 위함이 대부분이기 때문에 원본의 값이 변하지 않도록 하기 위해 깊은 복사가 필요하다

**깊은 복사의 순환 참조**

- 단순한 깊은 복사 방법은 순환 참조가 있는 객체를 반복할 때 오류에 빠질 수 있다.

<aside>
➡️

**파이썬의 메모리 관리 방식**

1. Reference Counting
    - 파이썬에서 주로 사용하는 메모리 관리 방식
    - 객체 참조가 생성될 때마다 카운트를 증가하고, 사라질때마다 카운트를 감소합니다. 참조가 0이 되었을때 해당 메모리를 해제시킵니다.
    - 실시간으로 객체를 회수할 수 있어 메모리 누수의 위험이 적습니다.
    - 순환참조 문제
        - 객체가 서로 참조하고 있어 서로의 카운트가 0이 될 수 없는 상황을 의미합니다.
2. generational garbage collection
    - 순환 참조 문제를 해결하기 위한 메모리 관리 방법
    - 새로 생성된 경우 0세대에 배치, GC이후 살아남은 객체의 경우 다음 세대로 이동
    - 세대가 높아질 수록 GC가 덜 발생하게 되어 효율적으로 메모리를 관리할 수 있다.
    - 레퍼런스 카운팅에 비해 오버헤드 발생 위험이 높은 편
</aside>

### 6.5 참조로서의 함수 매개변수

- 파이썬은 공유 호출로 하는 매개변수 전달 방식만 지원한다. (매개변수는 항상 주소로 전달)

**매개변수 기본값으로 부적당한 가변형**

- 기본값이 가변 객체일 때 이 객체를 변경하면 변경 내용이 향후 인스턴스 생성시 영향을 미친다
- 가변 기본값의 이러한 문제 때문에 가변값을 받는 매개변수의 기본 값으로 None을 주로 사용

**가변 매개변수에 대한 방어적 프로그래밍**

- 놀람 최소화 원칙
- 인수로 받은 객체를 메서드가 변경하리라고 명시적으로 기대하지 안는 한 클래스 안에서 인수를 변수에 할당함으로써 인수 객체에 별칭을 붙이는 것에 주의해야한다.
- 확실하지 않을 때는 사본을 만들어서 사용해야 한다.

### 6.6 del과 가비지 컬렉션

- del은 문장
- del은 참조를 제거할 뿐 객체를 제거하지 않음
- __del__은 객체가 제거되기 직전에 외부 리소스를 해제할 기회를 주려고 파이썬 인터프리터가 호출
- CPython은 참조 카운팅 방식 사용, 이때 0이 되면 객체 제거
- del의 부적절한 사용

### 6.7 파이썬이 불변형을 가지고 노는 기법

**인터닝**

- 불변 객체의 동일한 값에 대해 하나의 객체만 생성하여 재사용하는 최적화 기법을 의미한다
    
    ```python
    a = 5
    b = 5
    print(a is b) #True
    ```
    
- 인터닝된 문자열은 동일한 메모리 주소를 공유하므로 값 비교 뿐만 아니라 객체 비교도 True가 나올 수 있다.
- 길거나 공백이 포함되어 인터닝되지 않은 경우 직접 sys.intern(str)로 등록할 수 있다.
- 인터닝은 메모리-시간 트레드오프를 따른다. (한번 실행 시 끝까지 유지)

**CPython의 인터닝**

- CPython은 일부 불변 객체 타입에 자동으로 인터닝을 적용한다.
- 정수, 문자열 등등
- 이를 통해 메모리 감소와 성능향상을 이끌어낸다.

**frozen.copy()와 인터닝**

- 불변 객체의 frozenset에서는 인터닝과 유사한 메모리 최적화가 발생한다
- frozenset인스턴스에서 .copy 메서드를 호출하면 새 객체를 만들지 않고 자기 자신을 그대로 반환한다.
- 즉 frozenset의 copy는 실제로 복사를 수행하지 않고 객체를 재사용한다는 것을 알 수 있다. 내용이 불변이므로 굳이 새로운 객체를 할당할 필요가 없기 때문에 이와 같은 방식을 사용한다.
- 원본 전체를 복사한 튜플도 마찬가지
- CPython에서 모든 불변 객체에 대해 내용이 동일한 복사 연산은 자기 자신을 반환하도록 구현

<aside>
➡️

Cpython에서의 불변 객체 copy 이슈

https://github.com/python/cpython/issues/88869

</aside>
