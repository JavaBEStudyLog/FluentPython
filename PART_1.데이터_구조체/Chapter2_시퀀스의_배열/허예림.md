### 2.2 내장 시퀀스 개요

파이썬의 시퀀스는 메모리 사용 방식, 가변성 여부, 자료형의 다양성 등에 따라 여러가지로 분류할 수 있다.

- 시퀀스 : 데이터를 순서대로 저장하는 자료형을 의미

**컨테이너 시퀀스**

- 서로 다른 자료형의 항목을 다를 수 있는 시퀀스
- 내부적으로 각 요소에 대한 참조를 저장하는 방식으로 동작 → 메모리에 연속적으로 저장되지 않음
- list, tuple, deque등

**균일 시퀀스**

- 하나의 타입의 자료형만 다룰수 있는 시퀀스
- 직접 데이터를 저장하는 방식으로 동작한다. → 메모리를 연속적으로 저장한다.
- 메모리 사용이 효율적이고 속도가 빠르다
- str, bytes, array

**가변 시퀀스**

- 객체가 생성된 후 내부 요소를 변경할 수 있는 시퀀스 → 요소를 추가, 삭제, 변경 가능
- 가변 시퀀스는 불변 시퀀스를 상속하면서 여러가지 메서드를 추가로 구현하여 동작
- list, bytearray, array, deque등

**불변 시퀀스**

- 객체가 한번 생성된 후 내부 요소를 변경할 수 없는 시퀀스
- tuple, str, bytes등

**시퀀스 계층 구조**

- 시퀀스는 collection.abc.Sequence를 중심으로 계층 구조를 가진다.
- collections.abc.Iterable : Iterable을 상속받아 반복 가능
- Container : in 연산자를 활용하여 요소가 포함되어 있는지 확인
- Sized : len() 사용 가능
- Sequen

### 2.3 지능형 리스트와 제너레이터 표현식

### 2.3.1 지능형 리스트와 가독성

파이썬에서는 리스트 형태의 데이터를 보다 효율적으로 다룰 수 있도록 **지능형 리스트(List Comprehension)**와 **제너레이터 표현식(Generator Expression)**을 제공한다. 이를 활용하면 간결한 문법으로 시퀀스를 생성할 수 있으며, 성능과 가독성을 향상시키는 데 기여할 수 있다.

**지능형 리스트**

- 기존의 for 루프를 이용한 리스트 생성 방식보다 직관적이고 간결한 코드로 동일한 결과를 얻을 수 있음
- 리스트가 길거나 복잡한 연산이 포함되면 오히려 가독성이 떨어질 수 있음
- 람다 함수 없이도 map, filter 등 수행 가능

**제너레이터 표현식**

- 리스트를 한꺼번에 메모리에 로드하지 않고 필요할 때마다 값을 생성하는 방식
- 지능형 리스트와 유사하지만 메모리 효율성이 뛰어난 편
- for문과 함께 사용할때 성능 최적화 효과

**map(), filter()**

- 메모리를 즉시 점유하지 않고 필요한 순간에만 값 생성 → 지연 평가
    - map과 filter는 iterator를 반환한다. 값을 요청할때마다 하나씩 생성하여 반환하는 방식으로 필요한 순간에만 메모리에 적재하여 계산 수행
    - 지연 평가 : 값이 실제로 필요할 때까지 연산을 미루는 방법
    - java에서는 스트림에서 지연 평가 (생성 → 중간 연산 → 최종 연산)
    - 제너레이터 표현식도 마찬가지로 지연 평가
    - 지연팡가의 대상 객체는 한번 사용대면 재사용할 수 없음
    - 이터레이터는 상태를 유지하며 한번만 순회할 수 있다
    - 이터레이터 : 상태를 유지하며 한 방향으로만 진행하기 때문에 한번 소비하면 재사용할 수 없다.
    - 이터러블 : list, tuple, set, str등은 iterable하며 여러번 순회가가능
    - (내부적으로 ierable 객체를 새로 생성하는 메서드가  있고 이 메서드 호출 시 새로운 메서드 생성하여 반환)
        
        ```java
        lst = [1, 2, 3]  # 리스트 (이터러블)
        
        it1 = iter(lst)  # 첫 번째 이터레이터 생성
        it2 = iter(lst)  # 두 번째 이터레이터 생성 (it1과 다른 객체)
        
        # 두 이터레이터 객체가 서로 다름
        print(it1 is it2)  # False
        
        # 첫 번째 이터레이터 사용
        print(next(it1))  # 1
        print(next(it1))  # 2
        
        # 두 번째 이터레이터는 처음부터 독립적으로 진행됨
        print(next(it2))  # 1
        print(next(it2))  # 2
        
        lst = [1, 2, 3]
        
        # 같은 이터러블에서 만든 두 개의 이터레이터는 서로 다름
        print(iter(lst) is iter(lst))  # False
        
        it = iter(lst)  # 이터레이터 생성
        print(iter(it) is iter(it))  # True (이터레이터는 자기 자신을 반환)
        
        ```
        
- 람다 함수를 사용해야 함

### 2.3.3 데카르트 곱

- 여러 개의 **반복 가능한(iterable) 데이터 구조에서 가능한 모든 조합을 생성하는 방법**

**지능형 리스트를 이용한 데카르트 곱**

- **for문을 중첩하여** 첫 번째 리스트의 요소와 두 번째 리스트의 요소를 결합한 새로운 리스트를 만들 수 있음
- **순서를 변경하면 정렬 방식이 달라짐**
    - 색상을 먼저 반복하면 색상이 먼저 정렬됨
    - 크기를 먼저 반복하면 크기가 먼저 정렬됨
- **지능형 리스트를 사용하면 코드가 간결하고 가독성이 좋음**

**제너레이터 표현식 활용**

- **지능형 리스트는 단순한 리스트만 생성 가능**
- **더 복잡한 반복 가능한 객체를 다룰 경우, 제너레이터 표현식이 더 적합**
- **제너레이터 표현식은 메모리를 절약하면서 데이터를 필요할 때마다 생성 가능**

### 2.3.4 제너레이터 표현식

- **튜플, 배열과 같은 시퀀스를 초기화할 때 지능형 리스트를 사용하는 대신, 메모리를 더 효율적으로 활용하는 방식**
- 지능형 리스트는 **한 번에 모든 요소를 리스트로 생성하여 메모리에 저장**
- 제너레이터 표현식은 **필요한 순간에 하나씩 항목을 생성하는 방식**으로 동작 → **메모리 절약 효과**

**제너레이터 표현식의 특징**

- **반복자 프로토콜을 따름**
- **요소를 한꺼번에 리스트로 변환하지 않고, 필요할 때마다 하나씩 생성**
- **대량의 데이터를 처리할 때 메모리 사용을 절약할 수 있음**
- **제너레이터 표현식은 리스트를 한 번에 만들지 않으므로, 전체 데이터를 즉시 접근해야 하는 경우 적합하지 않음**

### 2.4 불변 리스트를 뛰어넘는 튜플

### **2.4.1 레코드로서의 튜플**

파이썬에서 **튜플은 단순한 불변 리스트(immutable list) 이상의 역할**을 수행할 수 있다. 튜플은 **불변 리스트처럼 사용할 수도 있지만, 필드가 없는 레코드(record) 형태로도 활용**될 수 있다. 즉, **튜플을 사용할 때 불변 리스트로 사용할 것인지, 레코드로 활용할 것인지**에 대한 개념을 명확히 이해하는 것이 중요하다.

### **튜플을 레코드로 사용할 때의 특징**

- 튜플의 **각 항목은 레코드의 필드 하나를 의미**하며, **항목의 위치가 의미를 결정하는 역할**을 함
- 리스트를 레코드처럼 사용하려면 필드 크기나 순서가 중요할 수 있지만, **튜플은 불변성을 가지므로 레코드 데이터를 저장할 때 안정성이 높음**
- **튜플 언패킹 기능**을 활용하면 데이터를 보다 직관적으로 다룰 수 있음
- 예제에서는 **로스앤젤레스 국제공항(LAX)의 위도와 경도를 저장**하는 방식과 **지역 데이터를 튜플 형태로 다루는 방식**을 보여줌
- 또한, **여권 번호와 국가 코드를 포함하는 튜플 리스트를 생성하고, 각 요소를 정렬하여 출력하는 방법**을 설명함

### **튜플의 언패킹 기능**

- **튜플 언패킹을 활용하면 데이터를 보다 직관적으로 처리 가능**
- 변수를 개별적으로 다룰 필요 없이 **한 줄의 코드로 여러 개의 값을 처리 가능**
- 예제에서는 `traveler_ids`라는 튜플 리스트를 사용하여 **여권 정보를 저장하고, 각 요소를 언패킹하여 국가 코드와 여권 번호를 개별 변수에 할당하는 방식**을 설명함

### **튜플 사용 시 주의할 점**

- **튜플은 불변 객체이므로 수정할 수 없음**
- 항목의 개수가 바뀌거나 일부 값이 수정될 가능성이 있는 데이터라면, **튜플보다 리스트, 네임드 튜플(namedtuple), 데이터 클래스(dataclass) 같은 구조를 활용하는 것이 적절함**

### **튜플을 불변 리스트로 활용할 때의 장점**

1. **명확성**
    - 코드에서 **튜플을 사용하면 해당 리스트의 길이가 절대 바뀌지 않는다는 것을 직관적으로 알 수 있음**
    - 리스트는 항목을 추가하거나 제거할 수 있지만, **튜플은 한 번 정의되면 구조가 변하지 않음**
    - 유지보수 시 **데이터의 안정성을 보장할 수 있음**
2. **성능**
    - 튜플은 **리스트보다 메모리를 더 적게 소비**하며, **파이썬 인터프리터가 튜플을 최적화하여 더 빠르게 실행할 수 있도록 함**
    - 리스트는 가변적인 구조이므로 추가적인 메모리 할당과 관리가 필요하지만, **튜플은 불변이므로 이러한 부담이 줄어듦**

### **튜플 내부에 가변 객체가 포함된 경우**

- **튜플이 불변이라고 해서 그 안에 포함된 객체까지 불변인 것은 아님**
- 예를 들어, **튜플 내부에 리스트 같은 가변 객체가 포함되어 있다면, 해당 리스트의 내용은 변경 가능**
- 이를 통해 **같은 튜플이라도 내부 가변 객체가 변경되면 새로운 값처럼 동작할 수 있음**
- 따라서, **튜플을 사용할 때는 내부 항목이 변경될 가능성이 있는지를 고려해야 함**

### **튜플과 해시 가능성**

- **튜플이 해시 가능한지 여부는 항목의 가변성에 따라 달라짐**
- 모든 항목이 **불변 객체로만 구성된 튜플은 해시 가능**하며, `set`이나 `dict`의 키로 사용할 수 있음
- 하지만 **리스트 같은 가변 객체가 포함된 튜플은 해시할 수 없음**
- **이러한 경우에는 다른 자료구조를 고려하는 것이 적절함**

### **튜플과 리스트의 성능 차이**

- **리스트는 항목을 추가하거나 제거할 수 있도록 설계되어 있어 내부적으로 더 많은 관리 작업이 필요**
- 반면, **튜플은 생성될 때 크기가 고정되므로 더 효율적으로 메모리에 저장됨**
- 리스트는 다른 곳에서 참조하는 경우가 많아 관리가 복잡해질 수 있지만, **튜플은 상대적으로 간단한 구조를 가지므로 처리 속도가 더 빠를 수 있음**

### 2.5 시퀀스와 반복형 객체의 언패킹

### **언패킹(Unpacking) 이란?**

- **파이썬의 언패킹 기능은 시퀀스나 반복 가능한 객체에서 항목을 추출하여 여러 개의 변수에 할당하는 기능**
- **코드를 더 간결하게 작성할 수 있으며, 가독성을 높이는 데 도움을 줌**
- 언패킹은 **특히 함수의 반환 값을 여러 개의 변수로 나눠 받을 때 유용**

### **기본적인 언패킹**

- **튜플이나 리스트의 요소를 변수에 직접 할당하는 방식**
- 예를 들어, **좌표 데이터를 튜플로 저장한 후 개별 변수로 언패킹 가능**
- 함수의 반환 값을 여러 개의 변수로 나눠 받을 수도 있음

### **여러 개의 값을 한 번에 교환 (swap)**

- 중간 변수를 사용하지 않고, **한 줄의 코드로 두 변수의 값을 교환 가능**

### **함수 호출 시에도 언패킹이 유용**

- 함수가 여러 개의 값을 반환할 때, 이를 **각각의 변수에 할당 가능**
- 예를 들어, **몫과 나머지를 동시에 저장하는 경우 유용**

### **파일 경로 다루기**

- `os.path.split()` 함수를 활용하면 **파일명과 확장자를 쉽게 분리할 수 있음**

### **별표(*)를 사용한 언패킹**

- 리스트나 튜플에서 **특정 부분만 가져오고 나머지는 무시 가능**
- 이를 활용하면 **특정 부분만 쉽게 추출 가능**

### **중첩된 데이터 구조에서도 언패킹 가능**

- 예를 들어, **도시 정보를 담고 있는 튜플 리스트에서 특정 필드만 추출 가능**
- for 문을 활용하여 **불필요한 데이터를 무시하고 필요한 값만 저장 가능**

### **주의할 점**

- SQL 쿼리의 실행 결과처럼 **단일 레코드가 반환되는 경우에도 언패킹 활용 가능**
- 단, **튜플의 항목이 하나만 있는 경우(value,)처럼 쉼표를 붙여야 하는 문법적 주의가 필요함**
