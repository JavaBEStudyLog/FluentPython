### 2.2 내장 시퀀스 개요

파이썬의 시퀀스는 메모리 사용 방식, 가변성 여부, 자료형의 다양성 등에 따라 여러가지로 분류할 수 있다.

- 시퀀스 : 데이터를 순서대로 저장하는 자료형을 의미

**컨테이너 시퀀스**

- 서로 다른 자료형의 항목을 다를 수 있는 시퀀스
- 내부적으로 각 요소에 대한 참조를 저장하는 방식으로 동작 → 메모리에 연속적으로 저장되지 않음
- list, tuple, deque등

**균일 시퀀스**

- 하나의 타입의 자료형만 다룰수 있는 시퀀스
- 직접 데이터를 저장하는 방식으로 동작한다. → 메모리를 연속적으로 저장한다.
- 메모리 사용이 효율적이고 속도가 빠르다
- str, bytes, array

**가변 시퀀스**

- 객체가 생성된 후 내부 요소를 변경할 수 있는 시퀀스 → 요소를 추가, 삭제, 변경 가능
- 가변 시퀀스는 불변 시퀀스를 상속하면서 여러가지 메서드를 추가로 구현하여 동작
- list, bytearray, array, deque등

**불변 시퀀스**

- 객체가 한번 생성된 후 내부 요소를 변경할 수 없는 시퀀스
- tuple, str, bytes등

**시퀀스 계층 구조**

- 시퀀스는 collection.abc.Sequence를 중심으로 계층 구조를 가진다.
- collections.abc.Iterable : Iterable을 상속받아 반복 가능
- Container : in 연산자를 활용하여 요소가 포함되어 있는지 확인
- Sized : len() 사용 가능
- Sequen

### 2.3 지능형 리스트와 제너레이터 표현식

### 2.3.1 지능형 리스트와 가독성

파이썬에서는 리스트 형태의 데이터를 보다 효율적으로 다룰 수 있도록 **지능형 리스트(List Comprehension)**와 **제너레이터 표현식(Generator Expression)**을 제공한다. 이를 활용하면 간결한 문법으로 시퀀스를 생성할 수 있으며, 성능과 가독성을 향상시키는 데 기여할 수 있다.

**지능형 리스트**

- 기존의 for 루프를 이용한 리스트 생성 방식보다 직관적이고 간결한 코드로 동일한 결과를 얻을 수 있음
- 리스트가 길거나 복잡한 연산이 포함되면 오히려 가독성이 떨어질 수 있음
- 람다 함수 없이도 map, filter 등 수행 가능

**제너레이터 표현식**

- 리스트를 한꺼번에 메모리에 로드하지 않고 필요할 때마다 값을 생성하는 방식
- 지능형 리스트와 유사하지만 메모리 효율성이 뛰어난 편
- for문과 함께 사용할때 성능 최적화 효과

**map(), filter()**

- 메모리를 즉시 점유하지 않고 필요한 순간에만 값 생성 → 지연 평가
    - map과 filter는 iterator를 반환한다. 값을 요청할때마다 하나씩 생성하여 반환하는 방식으로 필요한 순간에만 메모리에 적재하여 계산 수행
    - 지연 평가 : 값이 실제로 필요할 때까지 연산을 미루는 방법
    - java에서는 스트림에서 지연 평가 (생성 → 중간 연산 → 최종 연산)
    - 제너레이터 표현식도 마찬가지로 지연 평가
    - 지연팡가의 대상 객체는 한번 사용대면 재사용할 수 없음
    - 이터레이터는 상태를 유지하며 한번만 순회할 수 있다
    - 이터레이터 : 상태를 유지하며 한 방향으로만 진행하기 때문에 한번 소비하면 재사용할 수 없다.
    - 이터러블 : list, tuple, set, str등은 iterable하며 여러번 순회가가능
    - (내부적으로 ierable 객체를 새로 생성하는 메서드가  있고 이 메서드 호출 시 새로운 메서드 생성하여 반환)
        
        ```java
        lst = [1, 2, 3]  # 리스트 (이터러블)
        
        it1 = iter(lst)  # 첫 번째 이터레이터 생성
        it2 = iter(lst)  # 두 번째 이터레이터 생성 (it1과 다른 객체)
        
        # 두 이터레이터 객체가 서로 다름
        print(it1 is it2)  # False
        
        # 첫 번째 이터레이터 사용
        print(next(it1))  # 1
        print(next(it1))  # 2
        
        # 두 번째 이터레이터는 처음부터 독립적으로 진행됨
        print(next(it2))  # 1
        print(next(it2))  # 2
        
        lst = [1, 2, 3]
        
        # 같은 이터러블에서 만든 두 개의 이터레이터는 서로 다름
        print(iter(lst) is iter(lst))  # False
        
        it = iter(lst)  # 이터레이터 생성
        print(iter(it) is iter(it))  # True (이터레이터는 자기 자신을 반환)
        
        ```
        
- 람다 함수를 사용해야 함

### 2.3.3 데카르트 곱

- 여러 개의 **반복 가능한(iterable) 데이터 구조에서 가능한 모든 조합을 생성하는 방법**

**지능형 리스트를 이용한 데카르트 곱**

- **for문을 중첩하여** 첫 번째 리스트의 요소와 두 번째 리스트의 요소를 결합한 새로운 리스트를 만들 수 있음
- **순서를 변경하면 정렬 방식이 달라짐**
    - 색상을 먼저 반복하면 색상이 먼저 정렬됨
    - 크기를 먼저 반복하면 크기가 먼저 정렬됨
- **지능형 리스트를 사용하면 코드가 간결하고 가독성이 좋음**

**제너레이터 표현식 활용**

- **지능형 리스트는 단순한 리스트만 생성 가능**
- **더 복잡한 반복 가능한 객체를 다룰 경우, 제너레이터 표현식이 더 적합**
- **제너레이터 표현식은 메모리를 절약하면서 데이터를 필요할 때마다 생성 가능**

### 2.3.4 제너레이터 표현식

- **튜플, 배열과 같은 시퀀스를 초기화할 때 지능형 리스트를 사용하는 대신, 메모리를 더 효율적으로 활용하는 방식**
- 지능형 리스트는 **한 번에 모든 요소를 리스트로 생성하여 메모리에 저장**
- 제너레이터 표현식은 **필요한 순간에 하나씩 항목을 생성하는 방식**으로 동작 → **메모리 절약 효과**

**제너레이터 표현식의 특징**

- **반복자 프로토콜을 따름**
- **요소를 한꺼번에 리스트로 변환하지 않고, 필요할 때마다 하나씩 생성**
- **대량의 데이터를 처리할 때 메모리 사용을 절약할 수 있음**
- **제너레이터 표현식은 리스트를 한 번에 만들지 않으므로, 전체 데이터를 즉시 접근해야 하는 경우 적합하지 않음**

### 2.4 불변 리스트를 뛰어넘는 튜플

### **2.4.1 레코드로서의 튜플**

파이썬에서 **튜플은 단순한 불변 리스트(immutable list) 이상의 역할**을 수행할 수 있다. 튜플은 **불변 리스트처럼 사용할 수도 있지만, 필드가 없는 레코드(record) 형태로도 활용**될 수 있다. 즉, **튜플을 사용할 때 불변 리스트로 사용할 것인지, 레코드로 활용할 것인지**에 대한 개념을 명확히 이해하는 것이 중요하다.

### **튜플을 레코드로 사용할 때의 특징**

- 튜플의 **각 항목은 레코드의 필드 하나를 의미**하며, **항목의 위치가 의미를 결정하는 역할**을 함
- 리스트를 레코드처럼 사용하려면 필드 크기나 순서가 중요할 수 있지만, **튜플은 불변성을 가지므로 레코드 데이터를 저장할 때 안정성이 높음**
- **튜플 언패킹 기능**을 활용하면 데이터를 보다 직관적으로 다룰 수 있음
- 예제에서는 **로스앤젤레스 국제공항(LAX)의 위도와 경도를 저장**하는 방식과 **지역 데이터를 튜플 형태로 다루는 방식**을 보여줌
- 또한, **여권 번호와 국가 코드를 포함하는 튜플 리스트를 생성하고, 각 요소를 정렬하여 출력하는 방법**을 설명함

### **튜플의 언패킹 기능**

- **튜플 언패킹을 활용하면 데이터를 보다 직관적으로 처리 가능**
- 변수를 개별적으로 다룰 필요 없이 **한 줄의 코드로 여러 개의 값을 처리 가능**
- 예제에서는 `traveler_ids`라는 튜플 리스트를 사용하여 **여권 정보를 저장하고, 각 요소를 언패킹하여 국가 코드와 여권 번호를 개별 변수에 할당하는 방식**을 설명함

### **튜플 사용 시 주의할 점**

- **튜플은 불변 객체이므로 수정할 수 없음**
- 항목의 개수가 바뀌거나 일부 값이 수정될 가능성이 있는 데이터라면, **튜플보다 리스트, 네임드 튜플(namedtuple), 데이터 클래스(dataclass) 같은 구조를 활용하는 것이 적절함**

### **튜플을 불변 리스트로 활용할 때의 장점**

1. **명확성**
    - 코드에서 **튜플을 사용하면 해당 리스트의 길이가 절대 바뀌지 않는다는 것을 직관적으로 알 수 있음**
    - 리스트는 항목을 추가하거나 제거할 수 있지만, **튜플은 한 번 정의되면 구조가 변하지 않음**
    - 유지보수 시 **데이터의 안정성을 보장할 수 있음**
2. **성능**
    - 튜플은 **리스트보다 메모리를 더 적게 소비**하며, **파이썬 인터프리터가 튜플을 최적화하여 더 빠르게 실행할 수 있도록 함**
    - 리스트는 가변적인 구조이므로 추가적인 메모리 할당과 관리가 필요하지만, **튜플은 불변이므로 이러한 부담이 줄어듦**

### **튜플 내부에 가변 객체가 포함된 경우**

- **튜플이 불변이라고 해서 그 안에 포함된 객체까지 불변인 것은 아님**
- 예를 들어, **튜플 내부에 리스트 같은 가변 객체가 포함되어 있다면, 해당 리스트의 내용은 변경 가능**
- 이를 통해 **같은 튜플이라도 내부 가변 객체가 변경되면 새로운 값처럼 동작할 수 있음**
- 따라서, **튜플을 사용할 때는 내부 항목이 변경될 가능성이 있는지를 고려해야 함**

### **튜플과 해시 가능성**

- **튜플이 해시 가능한지 여부는 항목의 가변성에 따라 달라짐**
- 모든 항목이 **불변 객체로만 구성된 튜플은 해시 가능**하며, `set`이나 `dict`의 키로 사용할 수 있음
- 하지만 **리스트 같은 가변 객체가 포함된 튜플은 해시할 수 없음**
- **이러한 경우에는 다른 자료구조를 고려하는 것이 적절함**

### **튜플과 리스트의 성능 차이**

- **리스트는 항목을 추가하거나 제거할 수 있도록 설계되어 있어 내부적으로 더 많은 관리 작업이 필요**
- 반면, **튜플은 생성될 때 크기가 고정되므로 더 효율적으로 메모리에 저장됨**
- 리스트는 다른 곳에서 참조하는 경우가 많아 관리가 복잡해질 수 있지만, **튜플은 상대적으로 간단한 구조를 가지므로 처리 속도가 더 빠를 수 있음**

### 2.5 시퀀스와 반복형 객체의 언패킹

- 언패킹 : 시퀀스(리스트, 튜플, 문자열 등)이나 Iterable한 객체에서 개별 항목을 추출는 기능
- 인덱스를 사용하여 직접 요소에 접근하는 방식보다 간결하고 직관적인 코드 작성이 가능하다.
    
    ```python
    abc_list = (1, 2, 3)
    a, b, c = abc_list 
    print(a, b, c) # 1 2 3
    
    ```
    
- 제너레이터,set, 딕셔너리와 같은 인덱싱을 지원하지 않는 객체에서 더 유용하다.
    
    ```python
    def generate():
        yield 10
        yield 20
        yield 30
    
    x, y, z = generate()
    print(x, y, z)  # 출력: 10 20 30
    
    ```
    
- 초과된 항목 : 데이터 개수가 변수보다 많으면 *를 사용하여 초과된 항목을 리스트로 묶을 수 있다.
    
    ```python
    numbers = (1, 2, 3, 4, 5)
    a, *b, c = numbers
    print(a)  # 1
    print(b)  # [2, 3, 4] (중간 값들을 리스트로 묶음)
    print(c)  # 5
    
    ```
    

**병렬 할당**

- 튜플을 활용한 언패킹은 병렬 할당을 할 때 자주 사용된다.
- 여러 개의 변수를 동시에 할당 할 수 있어 변수 교환에도 많이 쓰인다.

```python
a, b = 10, 20
a, b = b, a  # 변수 값 교환
print(a, b)  # 출력: 20 10

```

함수 매개변수에서의 언패킹 - 인자 언패킹 (*args, **kwargs)

- *args와 **kwargs를 사용하면 가변 개수의 인수를 처리 할 수 있다.

```java
def my_func(*args):
    print(args)  # 튜플로 변환됨

my_func(1, 2, 3)  # 출력: (1, 2, 3)

def my_func(**kwargs):
    print(kwargs)  # 딕셔너리로 변환됨

my_func(name="Alice", age=25)  # 출력: {'name': 'Alice', 'age': 25}

```

**중첩 언패킹**

```python
data = (1, (2, 3), 4)

a, (b, c), d = data
print(a, b, c, d)  # 출력: 1 2 3 4

```

**언패킹과 enumerate()**

```python
fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(index, fruit)

```

**언패킹과 zip()**

```python
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(name, age)

```

### 2.7 슬라이싱

- 슬라이싱 연산 :

**슬라이스 범위**

- 슬라이스 범위에서 마지막 항목을 제외하는 이유
- 시작점과 중단점을 모두 지정할 때 길이를 계산하기 쉽다.
- 인덱스를 기준으로 겹침없이 분할하기 쉽다.

**다차원 슬라이싱**

- [] 연산자는 쉼표를 사용해 여러개의 인덱스나 슬라이스를 가질 수 있다.
- __get_item__() 및 __set_item__() 메서드는 인덱스를 튜플로 받는다.
    
    ```python
    a[i,j] -> a.__getitem__((i, j))
    ```
    
- 슬라이싱은 numpy 같은 패키지에서 a[i, j]혹은 a[m:n ,k:l] 형태로 2차원 데이터를 슬라이싱 할때 도 사용된다.

**Ellipsis …** 

- …은 파이썬에서 하나의 토큰으로 인식된다.
    
    ```python
    x[i, ...]
    ```
    
- 다차원 배열 x에서 첫번째 차원의 i번째 요소를 선택한 후 나머지 모든 차원은 그대로 유지하는 슬라이싱 즉 x[i, :, :, :, :]를 생략하여 표현한 구조
- numpy 패키지에서 특히 자주 사용됨

**슬라이스에 할당하기**

```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20,30]
[0,1,20,30,4,5,6,7,8,9]
```

### 2.8 **시퀀스에 덧셉과 곱셈 연산자 사용하기**

- 시퀀스에서 덧셈과 곱셈 연산자를 활용하여 새로운 시퀀스를 만들 수 있다.
- 이때 새로운 시퀀스를 생성할 뿐 기존의 시퀀스를 변경하지 않는다.

```python
l = [1, 2, 3]
l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

**List Comprehension**

```python
board = [['_'] * 3 for i in range(3)]
```

**시퀀스의 복합 할당**

- += 연산자는 객체의 특성에 따라  __iadd__()(in-place addition, 객체 값 변경), __add__() (객체 생성) __imul__() 이 호출되어 연산된다.
- __iadd__() 연산자
    - 객체를 직접 수정하는 연산을 수행한다.
    - 가변 객체 (list, bytearray)등에서 사용된다.
    - 이 메서드를 수행할 경우 += 연산을 수행해도 새로운 객체를 생성하지 않고 기존 객체를 변경한다.
- __add__() 연산자
    - 새로운 객체를 생성하는 연산자이다.
    - 튜플, 문자열과 같은 불변객체에서 사용된다.
    - __iadd__가 없거나 객체가 불변인경우 += 연산자는 새로운 객체를 생성한 후 변수에 재할당한다. (불변 객체에서는 __iadd__ 가 없다. 사용자가 직접 만든 클래스의 경우에도 구현되지 않을 수 있다.)
        
        ```python
        t = (1, 2, 3)
        print(id(t))  # 초기 튜플 ID
        
        t += (4, 5, 6)  # 내부적으로 t = t.__add__((4, 5, 6)) 호출됨
        print(t)  # (1, 2, 3, 4, 5, 6)
        
        print(id(t))  # 새로운 튜플 객체가 생성됨 (ID 변경됨)
        
        ```
        

### 2.9 list.sort()와 sorted()

**list.sort()**

- 리스트 객체의 내장 메서드, 리스트 자체를 정렬
- 새로운 리스트를 반환하지 않고 None을 반환
- 원본 리스트가 변경되므로 새로운 리스트가 필요하지 않을 때 유용하다. (메모리 절약)
- 반환 값이 None 이기 때문에 체이닝이 불가능하며 가변 리스트에서만 사용 가능
- key를 통해 정렬 기준을 설정하거나 reverse를 통해 거꾸로 계산할 수 있다.

**sorted()**

- 내장 함수이며 리스트 뿐 아니라 모든 iterable한 객체에서 사용가능
- 정렬된 새로운 리스트를 반환하며 원본 객체는 변경되지 않는다.
- 따라서 원본을 유지해야 하는 경우 유용하며, 불변객체에서도 사용가능하다.
- key를 통해 정렬 기준을 설정하거나 reverse를 통해 거꾸로 계산할 수 있다.

### 2.10 리스트 외

**배열**

- 리스트와 유사하지만 동일한 자료형만 저장 가능하여 효율적임
- pop, insert, extend등 연산 수행

**메모리뷰**

- 데이터를 복사하지 않고 기존 버퍼에 대한 참조를 제공
- 큰 데이터를 다룰 때 메모리 효율성을 극대화

**넘파이**

- 대규모 데이터 연산을 효율적으로 수행할 수 있는 계산 라이브러리
- 다차원 배열 지원
- 리스트보다 빠른 연산속도와 복잡한 연산 수행 가능
