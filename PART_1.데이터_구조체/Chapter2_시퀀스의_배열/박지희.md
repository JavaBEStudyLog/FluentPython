# CHAPTER 2 시퀀스의 배열

파이썬은 모든 시퀀스를 일관성있게 처리하는 ABC 언어의 특징을 물려받았다

> ABC 언어의 특징
>
> 1. 기본 데이터 유형이 5가지이다
> 2. 변수 선언 불필요
> 3. 하향식 프로그래밍 지원
> 4. 들여쓰기를 통한 코드 블록 구분
> 5. 무한 정밀 연산
> 6. 명령 완성, 지속적인 작업 공간 및 별도의 파일 처리가 없는 대화형 환경

문자열, 리스트, 바이트 시퀀스, 배열, XML 요소, 데이터베이스 결과에는 모두  
반복, 슬라이싱 정렬, 연결 등의 연산을 일관되게 적용할 수 있다

**<이번 장에서 다룰 주요 내용>**

- 지능형 리스트와 기본적인 제너레이터 표현식
- 튜플을 레코드로 사용할 때와 불변 리스트로 사용할 때의 차이점
- 시퀀스 언패킹과 시퀀스 패턴
- 슬라이스에서 읽고 슬라이스에 쓰기
- 배열과 큐 등 특화된 시퀀스형

## 2.1 이번 장의 변경 사항

(+) 2.6 '시퀀스를 이용한 패턴 매칭'  
(🔄) 명명된 튜플 -> 5.3 '고전적인 명명된 튜플'로 이동

## 2.2 내장 시퀀스 개요

파이썬 표준 라이브러리는 C로 구현된 시퀀스형을 제공한다

- 컨테이너 시퀀스
  - **서로 다른 자료형의 항목을 담을 수 있는** list, tuple, collections.deque 형
  - 객체에 대한 참조를 담음
  - 이 때 객체는 어떠한 자료형도 될 수 있음!
- 균일 시퀀스
  - **단 하나의 자료형만 담을 수 있는** str, bytes, array.array 형
  - 객체에 대한 참조 대신 **자신의 메모리 공간에 각 항목의 값을 직접 담음**

가변성에 따른 분류

- 가변 시퀀스
  - list, bytearray, array.array. collections.deque 형
- 불변 시퀀스
  - tuple.str, bytes 형

```bash
>>> from collections import abc
# tuple이 abc.Sequence를 상속받았는지 확인
>>> issubclass(tuple, abc.Sequence) # True

# list가 abc.MutableSequence을 상속받았는지 확인
>>> issubclass(list, abc.MutableSequence) # True
```

#### tuple과 list가 위 테스트를 통과하는 이유

1. 가변 시퀀스가 불변 시퀀스를 상속하면서 여러 메서드를 추가로 구현함
2. 내장된 구상 시퀀스형이 실제로 Sequence나 MutableSequence 추상 베이스 클래스(ABC)를 상속받지는 않음
3. 하지만 해당 추상 베이스 클래스가 요구하는 메서드들을 내장 시퀀스들이 이미 다 가지고 있음
4. 따라서 파이썬에서는 내장 시퀀스들을(tuple, list 등) 마치 해당 추상 클래스를 상속받은 것처럼 취급함  
   => tuple과 list는 abc.Sequence와 abc.MutableSequence의 가상 서브클래스라고 부를 수 있게 됨  
   왜냐하면 이들은 요구하는 메서드들을 다 가지고 있어서 **실제로 상속을 하지 않더라도, 마치 그 추상 클래스를 상속받은 것처럼 동작하기 때문**

## 2.3 지능형 리스트와 제너레이터 표현식

### 2.3.1 지능형 리스트와 가독성

#### 지능형 리스트 (List Comprehension == listcomp)

- 리스트를 간결하고 효율적으로 만들 수 있는 방법
- 일반적으로 리스트를 만들 때 반복문을 사용해서 하나씩 추가하는 방식을 사용하는데, 지능형 리스트를 사용하면 한 줄로 간단하게 리스트를 생성할 수 있음
- 항목을 필터링하고 변환함으로써 시퀀스나 기타 반복 가능한 자료형으로부터 리스트를 만듦

```python
# 일반적인 방법으로 리스트 생성
symbols = "$¢£¥€¤"
codes = []
for symbol in symbols:
  codes.append(ord(symbol))
print(codes) # [36, 162, 163, 165, 8364, 164]
```

```python
# 지능형 리스트로 리스트 생성
symbols = "$¢£¥€¤"
codes = [ord(symbol) for symbol in symbols]
print(codes) # [36, 162, 163, 165, 8364, 164]
```

### 2.3.2 지능형 리스트와 map() / filter() 조합의 비교

```python
# 지능형 리스트 사용
symbols = "$¢£¥€¤"
beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
print(beyond_ascii) # [162, 163, 165, 8364, 164]

# map() / filter() 사용
beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
print(beyon_ascii) # [162, 163, 165, 8364, 164]
```

### 2.3.3 데카르트 곱

- 두 개 이상의 집합에서 각 원소를 조합하는 연산
- 파이썬에서는 두 리스트의 모든 가능한 순서쌍을 만들 때 사용됨

```python
A = [1, 2]
B = ['a', 'b']

# 지능형 리스트를 사용한 데카르트 곱
cartesian_product = [(x, y) for x in A for y in B]
print(cartesian_product)  # [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
```

❗️ 지능형 리스트는 단지 리스트만 만들 수 있음! 다른 시퀀스를 만들려면 제너레이터 표현식을 사용해야 함

### 2.3.4 제너레이터 표현식 (Generator Expression == genexp)

- 지능형 리스트와 유사하지만, 전체 데이터를 한 번에 메모리에 저장하지 않고 반복자 프로토콜을 이용해 항목이 필요할 때마다 하나씩 생성
- 항목을 하나씩 생성해서 처리하기 때문에 대용량 데이터 처리에 유리
- 지능형 리스트와 똑같은 구문을 사용하지만, 대괄호 대신 소괄호를 사용!

```python
A = [1, 2]
B = ['a', 'b']

# 제너레이터 표현식을 사용한 데카르트 곱
cartesian_product_gen = ((x, y) for x in A for y in B)

# 제너레이터는 값을 하나씩 생성하므로, 이 값들을 순차적으로 출력
for pair in cartesian_product_gen:
    print(pair)
    # (1, 'a')
    # (1, 'b')
    # (2, 'a')
    # (2, 'b')
```

❗️ 지능형 리스트는 전체 결과를 한 번에 메모리에 저장하고 **리스트로 반환**  
❗️ 제너레이터 표현식은 결괄르 한 번에 모두 저장하지 않고 **값을 하나씩 생성**

## 2.4 불변 리스트를 뛰어넘는 튜플

튜플은 불변 리스트로 사용할 수도 있지만, 필드명이 없는 레코드로 사용할 수도 있다

### 2.4.1 레코드로서의 튜플

- 튜플의 각 항목은 레코드의 필드 하나를 의미하며 **항목의 위치가 의미를 결정**한다
  > 레코드란?  
  > 여러 개의 관련된 데이터를 하나의 단위로 묶은 것  
  > 여러 개의 필드(또는 컬럼)로 구성되며, 각 필드는 특정한 정보를 담고 있음
  >
  > Ex) 학생 레코드 => student_record = ("John", 20, "20250101")  
  > student_record는 이름, 나이, 학번을 담고 있는 레코드  
  > 각 항목은 필드를 의미하고, 각 필드는 특정한 정보를 나타냄
  >
  > ❗️각 항목의 위치가 무엇을 나타내는지 정해져 있음 -> 항목의 위치가 의미를 결정하게 됨

### 2.4.2 불변 리스트로서의 튜플

- 명확성
  - 코드 안에 tuple이 보이면 그 리스트의 길이가 절대 바뀌지 않음을 알 수 있다
- 성능
  - tuple은 똑같은 항목을 담은 list보다 메모리를 적게 소비하므로 파이썬 인터프리터가 최적화를 수행할 수 있다

❗️ tuple의 불변성은 그 안에 포함된 참조에만 적용된다는 점 주의!!  
튜플 안의 참조는 삭제되거나 바뀔 수 없다  
그러나 이러한 참조가 가변 객체를 가리키고, 해당 객체의 값이 바뀌면 tuple 값도 바뀐다

### 2.4.3 튜플과 리스트 메서드의 비교

- 튜플
  - 항목의 추가나 삭제 기능과 관련이 없는 list의 메서드를 모두 지원
  - 최적화로 인해 **reversed**() 메서드는 제공되지 않음
